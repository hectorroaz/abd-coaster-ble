<!doctype html>
<html lang="es">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ABD Coaster – Contador (BLE)</title>
<style>
  :root{--bg:#0b0b0d;--panel:#131317;--muted:#8b8b98;--accent:#5eead4;--text:#e6e6f0;--danger:#ef4444;--ok:#10b981}
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:880px;margin:0 auto;padding:18px}
  header{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
  .btn{appearance:none;border:1px solid #2a2a33;background:#1a1a22;color:var(--text);padding:.7rem 1rem;border-radius:12px;cursor:pointer;font-weight:600}
  .btn:hover{border-color:#3b3b46}.btn.primary{background:#1a2a29;border-color:#274c45;color:var(--accent)}
  .btn.danger{border-color:#3a1618;background:#1f0e10;color:var(--danger)}
  .row{display:grid;grid-template-columns:repeat(12,1fr);gap:14px;margin-top:16px}
  .card{grid-column:span 12;background:var(--panel);border:1px solid #20202a;border-radius:18px;padding:16px}
  @media(min-width:720px){.card.span6{grid-column:span 6}.card.span4{grid-column:span 4}.card.span8{grid-column:span 8}}
  .label{font-size:.9rem;color:var(--muted);letter-spacing:.04em;text-transform:uppercase}
  .big{font-size:5rem;line-height:1;font-weight:800;margin:.25em 0;cursor:pointer}
  .timer{font-variant-numeric:tabular-nums;font-size:2rem}
  .stat{font-variant-numeric:tabular-nums;font-size:1.6rem;font-weight:700}
  .muted{color:var(--muted)} .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;border:1px solid #2a2a33;color:var(--muted);font-size:.85rem}
  footer{margin:22px 0;color:var(--muted);font-size:.9rem}
  .toggle{display:inline-flex;align-items:center;gap:.5rem}.toggle input{width:18px;height:18px}

  /* Pantalla completa */
  .fullscreen{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center}
  .fullscreen.active{display:flex}
  .fsNum{color:#fff;font-weight:900;font-variant-numeric:tabular-nums;line-height:1;text-align:center;font-size:22vw}
  .fsHint{position:fixed;bottom:14px;left:0;right:0;text-align:center;color:#aaa;font-size:.95rem}
</style>

<div class="wrap">
  <header>
    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <button id="btnConnect" class="btn primary">Conectar BLE</button>
      <button id="btnReset" class="btn danger">Reset sesión</button>
      <label class="toggle"><input type="checkbox" id="vibrate"> Vibrar en cada rep</label>
    </div>
    <span id="status" class="pill">Desconectado</span>
  </header>

  <div class="row">
    <section class="card span8">
      <div class="label">Repeticiones (toca para pantalla completa)</div>
      <div id="reps" class="big">0</div>
      <div class="label">Cronómetro (desde la 1ª rep)</div>
      <div id="timer" class="timer">00:00</div>
    </section>

    <section class="card span4">
      <div class="label">Cadencia media</div><div id="avgCad" class="stat">0.00 rpm</div>
      <div class="label" style="margin-top:8px">Cadencia instantánea</div><div id="instCad" class="stat">—</div>
      <div class="label" style="margin-top:8px">Mejor cadencia</div><div id="bestCad" class="stat">—</div>
    </section>

    <section class="card span6">
      <div class="label">Tiempo última repetición</div>
      <div id="lastInt" class="stat">—</div>
      <div class="muted" style="margin-top:6px">Tiempo entre las dos últimas reps.</div>
    </section>

    <section class="card span6">
      <div class="label">Notas de sesión</div>
      <div id="notes" class="muted">Conecta el dispositivo; el cronómetro arranca con la primera repetición.</div>
    </section>
  </div>

  <footer><span class="muted">HR Creativos · ESP32 + Web Bluetooth · Tema oscuro</span></footer>
</div>

<!-- Pantalla completa -->
<div id="fs" class="fullscreen" onclick="exitFullScreen()">
  <div class="fsNum" id="fsNum">0</div>
  <div class="fsHint">Toca para salir</div>
</div>

<script>
/* ======== UUIDs ======== */
const SERVICE='7b1e0001-8b6b-4b6d-b6b3-6f6b7b1e0001';
const REPS   ='7b1e0004-8b6b-4b6d-b6b3-6f6b7b1e0001';

/* ======== UI ======== */
const $=s=>document.querySelector(s);
const ui={btnConnect:$('#btnConnect'),btnReset:$('#btnReset'),vibrate:$('#vibrate'),
  status:$('#status'),reps:$('#reps'),timer:$('#timer'),avgCad:$('#avgCad'),
  instCad:$('#instCad'),bestCad:$('#bestCad'),lastInt:$('#lastInt'),notes:$('#notes'),
  fs:$('#fs'),fsNum:$('#fsNum')};

/* ======== Estado sesión (lado cliente) ======== */
let device,server,svc,chReps;
let lastRepValue=null;     // último valor bruto que llegó del ESP32
let baselineReps=null;     // reps del ESP32 cuando empezó la sesión
let sessionReps=0;
let sessionStartMs=null;
let timerId=null;
let lastRepTs=null;
let bestCadRPM=0;
let awaitingFirstValue=false; // para fijar baseline al conectar/refrescar

/* ======== Util ======== */
function fmtTime(ms){if(ms==null)return'00:00';const s=Math.floor(ms/1000);return`${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;}
function setStatus(t,ok=false){ui.status.textContent=t;ui.status.style.color=ok?'var(--ok)':'var(--muted)';}
function startTimerIfNeeded(){ if(sessionStartMs!==null) return; sessionStartMs=Date.now(); timerId=setInterval(()=>{ const el=Date.now()-sessionStartMs; ui.timer.textContent=fmtTime(el); const m=el/60000; ui.avgCad.textContent=`${m>0?(sessionReps/m).toFixed(2):'0.00'} rpm`; },1000); }
function clearTimer(){ if(timerId) clearInterval(timerId); timerId=null; sessionStartMs=null; ui.timer.textContent='00:00'; ui.avgCad.textContent='0.00 rpm'; }

/* ======== Reset solo en la APP (baseline) ======== */
function resetSessionLocal() {
  // baseline = último valor bruto recibido del ESP32
  baselineReps = (lastRepValue ?? 0);
  sessionReps = 0;
  lastRepTs = null;
  bestCadRPM = 0;
  clearTimer();
  ui.reps.textContent='0'; ui.fsNum.textContent='0';
  ui.instCad.textContent='—'; ui.bestCad.textContent='—'; ui.lastInt.textContent='—';
  ui.notes.textContent='Sesión reiniciada (reset local).';
}
ui.btnReset.addEventListener('click', resetSessionLocal);

/* ======== Fullscreen ======== */
ui.reps.addEventListener('click', async ()=>{ ui.fs.classList.add('active'); try{ if(!document.fullscreenElement) await document.documentElement.requestFullscreen(); }catch{} });
async function exitFullScreen(){ ui.fs.classList.remove('active'); try{ if(document.fullscreenElement) await document.exitFullscreen(); }catch{} }
window.exitFullScreen = exitFullScreen;

/* ======== Wake Lock ======== */
let wakeLock=null; async function requestWakeLock(){ try{ if('wakeLock' in navigator){ wakeLock=await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release',()=>console.log('WakeLock release')); } }catch(e){ console.warn('WakeLock:', e.message); } }
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && !wakeLock) requestWakeLock(); });
requestWakeLock();

/* ======== Manejo de datos ======== */
function onRepsValue(dv){
  const raw = dv.getUint32(0,true);  // contador global del ESP32
  if (awaitingFirstValue) {
    // Al conectar tras refrescar: fijamos baseline = valor actual del ESP32
    baselineReps = raw;
    lastRepValue = raw;
    sessionReps = 0;
    awaitingFirstValue = false;
    clearTimer();
    ui.reps.textContent='0'; ui.fsNum.textContent='0';
    ui.instCad.textContent='—'; ui.bestCad.textContent='—'; ui.lastInt.textContent='—';
    ui.notes.textContent='Conectado. Sesión lista para empezar.';
    return; // próximo paquete ya contará normal
  }

  // Delta para cadencia (solo si avanzó)
  if (lastRepValue!==null && raw>lastRepValue){
    const now=Date.now();
    if (lastRepTs){ const dt=now-lastRepTs; const rpm=60000/dt; ui.lastInt.textContent=`${(dt/1000).toFixed(2)} s`; ui.instCad.textContent=`${rpm.toFixed(2)} rpm`; if(rpm>bestCadRPM){ bestCadRPM=rpm; ui.bestCad.textContent=`${bestCadRPM.toFixed(2)} rpm`; } }
    lastRepTs=now;
    startTimerIfNeeded();
  }

  lastRepValue = raw;

  // Reps de la sesión = crudo - baseline
  const s = Math.max(0, (baselineReps==null? raw : raw - baselineReps));
  sessionReps = s;
  ui.reps.textContent = String(s);
  ui.fsNum.textContent = String(s);
}

/* ======== Conexión / Reconexión ======== */
async function afterConnected(isReconnect){
  svc = await server.getPrimaryService(SERVICE);
  chReps = await svc.getCharacteristic(REPS);
  chReps.addEventListener('characteristicvaluechanged', e => onRepsValue(e.target.value));
  await chReps.startNotifications();
  setStatus('Conectado', true);
  ui.notes.textContent = 'La 1ª repetición inicia el cronómetro.';
  requestWakeLock();

  // Si es una reconexión en la misma pestaña, conservamos baseline.
  // Si venimos de un refresh (baselineReps === null), la primera notificación fijará baseline.
  awaitingFirstValue = (baselineReps === null);

  device.addEventListener('gattserverdisconnected', async ()=>{
    setStatus('Desconectado (reintentando...)', false);
    for(let i=0;i<5;i++){
      try{ await new Promise(r=>setTimeout(r, 800*(i+1))); if(!device.gatt.connected){ server = await device.gatt.connect(); await afterConnected(true); return; } }catch(e){ console.warn('reintento',i+1,e.message); }
    }
    setStatus('Desconectado', false);
  });
}

async function connectToKnownDevice(){
  if(device && device.gatt && !device.gatt.connected){
    setStatus('Reconectando...', false);
    server = await device.gatt.connect();
    await afterConnected(true);
    return true;
  }
  return false;
}

async function connectBLE(){
  try{
    if(await connectToKnownDevice()) return;

    setStatus('Buscando...', false);
    let dev;
    try{
      dev = await navigator.bluetooth.requestDevice({
        filters: [{ services:[SERVICE] }, { name:'ESP32-Pulsos' }, { namePrefix:'ESP32' }],
        optionalServices: [SERVICE]
      });
    }catch(e){
      if(e.name==='NotFoundError'){
        dev = await navigator.bluetooth.requestDevice({ acceptAllDevices:true, optionalServices:[SERVICE] });
      } else throw e;
    }
    device = dev; server = await device.gatt.connect();
    await afterConnected(false);
  }catch(err){
    console.error(err);
    setStatus('Error de conexión', false);
    alert('No pude conectar: ' + err.message);
  }
}
ui.btnConnect.addEventListener('click', connectBLE);

// Cierre/refresh: desconexión limpia
window.addEventListener('beforeunload', ()=>{ try{ if(device?.gatt?.connected) device.gatt.disconnect(); }catch{} });
</script>
</html>
